package com.denis.shuvalov.algo.old.chpter_2.insertionSort.book;

class ArrayIns
{
	private long[] a; // Ссылка на массив a
	private int nElems; // Количество элементов данных

	//--------------------------------------------------------------
	public ArrayIns(int max) // Конструктор
	{
		a = new long[max]; // Создание массива
		nElems = 0; // Пока нет ни одного элемента
	}

	//--------------------------------------------------------------
	public void insert(long value) // Вставка элемента в массив
	{
		a[nElems] = value; // Собственно вставка
		nElems++; // Увеличение размера
	}

	//--------------------------------------------------------------
	public void display() // Вывод содержимого массива
	{
		for (int j = 0; j < nElems; j++) // Для каждого элемента
			System.out.print(a[j] + " "); // Вывод
		System.out.println("");
	}

	//--------------------------------------------------------------
	public void insertionSort()
	{
		int in, out;
		for (out = 1; out < nElems; out++) // out - разделительный маркер
		{
			long temp = a[out]; // Скопировать помеченный элемент
			in = out; // Начать перемещения с out
			while (in > 0 && a[in - 1] >= temp) // Пока не найден меньший элемент
			{
				a[in] = a[in - 1]; // Сдвинуть элемент вправо
				--in; // Перейти на одну позицию влево
			}
			a[in] = temp; // Вставить помеченный элемент
		}
	}
	//--------------------------------------------------------------

	/**
	 * Нетрудно представить себе схему,
	 * в которой все элементы от позиции обнаружения дубликата до конца массива сдви-
	 * гаются на одну позицию, но это замедлит работу алгоритма до времени O(N^2) —
	 * по крайней мере при большом количестве дубликатов. Проследите за тем, чтобы
	 * в вашем алгоритме ни один элемент не перемещался более одного раза независи-
	 * мо от количества дубликатов — это обеспечит выполнение алгоритма за время O(N ).
	 */
	public void noDups()
	{
		this.insertionSort();
		display();

		int current = 0;
		int next    = 1;

		while (next < nElems)
		{
			if (a[next] == a[current])
			{
				next++;
			}
			else
			{
				current++;
				a[current] = a[next];
				next++;
			}
		}
	}

	/**
	 * Еще один простой алгоритм сортировки — сортировка методом четно-нечет-
	 * ных перестановок — основан на многократном выполнении двух проходов по мас-
	 * сиву. На первом проходе ищутся все пары элементов a[j] и a[j+1], где j — нечетное
	 * число (j = 1, 3, 5, …). Если ключи следуют в неверном порядке, элементы меняются
	 * местами. На втором проходе то же самое делается для всех четных значений (j = 2,
	 * 4, 6, …). Двухпроходная обработка выполняется многократно до тех пор, пока мас-
	 * сив не будет полностью отсортирован. Замените метод bubbleSort() в bubbleSort.
	 * java (листинг 3.1) методом четно-нечетных перестановок oddEvenSort(). Убедитесь
	 * в том, что он работает для произвольных объемов данных. Требуется определить,
	 * сколько раз будет выполняться двухпроходная обработка.
	 * Сортировка методом четно-нечетных перестановок очень полезна в многопро-
	 * цессорных конфигурациях, когда разные процессоры могут одновременно работать
	 * с разными нечетными (а затем и четными) парами. Так как нечетные пары неза-
	 * висимы друг от друга, каждая пара может проверяться (с перестановкой элементов
	 * в случае необходимости) отдельным процессором. Такая сортировка выполняется
	 * очень быстро.
	 */
	public void oddEvenSort()
	{

	}
}
